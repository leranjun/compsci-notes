{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"IB CompSci Notes \u00b6 Java Notes SL & HL Units 01 Computational Thinking 02 Problem-Solving & Java 02a Main 02b Project 03 System and Computer Organisation 03a User Focus 03b OS & Application Systems 03c Number Bases & Conversions 04 Object-Oriented Programming 05 Searching & Sorting Algorithms HL Only Units 01 Problem-Solving & Data Structures 1 02 Control 03 Abstract Data Structures 04 Resource Management","title":"IB CompSci Notes"},{"location":"#ib-compsci-notes","text":"Java Notes SL & HL Units 01 Computational Thinking 02 Problem-Solving & Java 02a Main 02b Project 03 System and Computer Organisation 03a User Focus 03b OS & Application Systems 03c Number Bases & Conversions 04 Object-Oriented Programming 05 Searching & Sorting Algorithms HL Only Units 01 Problem-Solving & Data Structures 1 02 Control 03 Abstract Data Structures 04 Resource Management","title":"IB CompSci Notes"},{"location":"java/","text":"Java Notes \u00b6 Boilerplate \u00b6 Attention The class name must be identical to the file name. public class className { public static void main ( String [] args ) { // Some code } } Output \u00b6 To print with a newline: System . out . println ( \"Hello World!\" ); To print without a newline: System . out . print ( \"Hello \" ); System . out . print ( \"World!\\n\" ); Input \u00b6 import java.util.Scanner ; // in main Scanner sc = new Scanner ( System . in ); String input = sc . nextLine (); Math \u00b6 Note Math is from java.lang.Math , which is imported by default. Min/Max \u00b6 int min = Math . min ( a , b ); int max = Math . max ( a , b ); Random \u00b6 int rand = min + ( int )( Math . random () * ( max - min ));","title":"Java Notes"},{"location":"java/#java-notes","text":"","title":"Java Notes"},{"location":"java/#boilerplate","text":"Attention The class name must be identical to the file name. public class className { public static void main ( String [] args ) { // Some code } }","title":"Boilerplate"},{"location":"java/#output","text":"To print with a newline: System . out . println ( \"Hello World!\" ); To print without a newline: System . out . print ( \"Hello \" ); System . out . print ( \"World!\\n\" );","title":"Output"},{"location":"java/#input","text":"import java.util.Scanner ; // in main Scanner sc = new Scanner ( System . in ); String input = sc . nextLine ();","title":"Input"},{"location":"java/#math","text":"Note Math is from java.lang.Math , which is imported by default.","title":"Math"},{"location":"java/#minmax","text":"int min = Math . min ( a , b ); int max = Math . max ( a , b );","title":"Min/Max"},{"location":"java/#random","text":"int rand = min + ( int )( Math . random () * ( max - min ));","title":"Random"},{"location":"HL/","text":"HL Units Index \u00b6 01 Problem-Solving & Data Structures 1 02 Control 03 Abstract Data Structures 04 Resource Management","title":"HL Units Index"},{"location":"HL/#hl-units-index","text":"01 Problem-Solving & Data Structures 1 02 Control 03 Abstract Data Structures 04 Resource Management","title":"HL Units Index"},{"location":"HL/01/","text":"01 Problem-Solving & Data Structures 1 \u00b6 1D Arrays \u00b6 An array is a fixed-size variable to store one or more values of a given data type. Declaration and initialization \u00b6 /* Can separate into 2 lines: <type>[] <name>; OR <type> <name>[]; <name> = new <type>[<size>]; */ int [] arr ; arr = new int [ 5 ] ; /* Or can combine into one line: <type>[] <name> = new <type>[<size>] */ int [] arr = new int [ 5 ] ; /* Or use an initializer list: <type>[] <name> = {<value1>, <value2>, ..., <valueN>}; */ int [] arr = { 1 , 2 , 3 , 4 , 5 }; Common usage \u00b6 Traverse with for loop \u00b6 for ( int i = 0 ; i < arr . length ; i ++ ) { System . out . println ( arr [ i ] ); }","title":"01 Problem-Solving & Data Structures 1"},{"location":"HL/01/#01-problem-solving-data-structures-1","text":"","title":"01 Problem-Solving &amp; Data Structures 1"},{"location":"HL/01/#1d-arrays","text":"An array is a fixed-size variable to store one or more values of a given data type.","title":"1D Arrays"},{"location":"HL/01/#declaration-and-initialization","text":"/* Can separate into 2 lines: <type>[] <name>; OR <type> <name>[]; <name> = new <type>[<size>]; */ int [] arr ; arr = new int [ 5 ] ; /* Or can combine into one line: <type>[] <name> = new <type>[<size>] */ int [] arr = new int [ 5 ] ; /* Or use an initializer list: <type>[] <name> = {<value1>, <value2>, ..., <valueN>}; */ int [] arr = { 1 , 2 , 3 , 4 , 5 };","title":"Declaration and initialization"},{"location":"HL/01/#common-usage","text":"","title":"Common usage"},{"location":"HL/01/#traverse-with-for-loop","text":"for ( int i = 0 ; i < arr . length ; i ++ ) { System . out . println ( arr [ i ] ); }","title":"Traverse with for loop"},{"location":"SLHL/","text":"SLHL Units Index \u00b6 01 Computational Thinking 02 Problem-Solving & Java 02a Main 02b Project 03 System and Computer Organisation 03a User Focus 03b OS & Application Systems 03c Number Bases & Conversions 04 Object-Oriented Programming 05 Searching & Sorting Algorithms","title":"SLHL Units Index"},{"location":"SLHL/#slhl-units-index","text":"01 Computational Thinking 02 Problem-Solving & Java 02a Main 02b Project 03 System and Computer Organisation 03a User Focus 03b OS & Application Systems 03c Number Bases & Conversions 04 Object-Oriented Programming 05 Searching & Sorting Algorithms","title":"SLHL Units Index"},{"location":"SLHL/01/","text":"01 Computational Thinking \u00b6 Summary Decomposition : break the problem down into its components & identify subproblems that need to be solved Pattern Recognition : recognise patterns between subproblems Abstraction/Pattern Generalisation : set up operations that can be used for the subproblems Algorithm Design : solve parallel & sequential subproblems Decomposition \u00b6 Breaking down complex problem/system -> smaller, more manageable, easier to understand parts Then examine/solve/design individually \u201cDivide and conquer\u201d Benefits \u00b6 Simpler to work with, easier to solve Deal with one at a time only Can straightforwardly understand each part before understanding the whole problem Different people can work on different parts at the same time Reduce development time Components can be reused in other programs Examples \u00b6 Brushing teeth which toothbrush to use how long to brush for how hard to press on our teeth what toothpaste to use Solving crime what crime was committed when the crime was committed where the crime was committed what evidence there is if there were any witnesses if there have recently been any similar crimes Creating app what kind of app do you want to create what your app will look like who is the target audience for your app what your graphics will look like what audio you will include what software you will use to build your app how the user will navigate your app how you will test your app where you will sell your app Pattern Recognition \u00b6 Finding patterns (similarity/common characteristics) among small, decomposed problems Benefits \u00b6 Use the same problem-solving solution for the same pattern Easier & quicker Solve more complex problems more efficiently Solve the problem correctly (because generalisations have been identified) Examples \u00b6 There might even be patterns within a problem, e.g. for each ingredient, we need its name and a specific measurement. Abstraction \u00b6 Filtering out/ignoring/taking away unnecessary characteristics/details to concentrate on necessary/essential ones Creating a model (an easier-to-understand version/general idea of a complex system) Tip A single abstraction can represent a whole class of similar things (e.g. for any bus route, we need the bus number, start/end time and bus stops to get on/off). This can be done through successive decomposition and by keeping general patterns and removing specific details . Benefits \u00b6 Can be viewed both as a process and as an entity (???) Enables concentration on essential aspects -> ignore distracting details Focus on the right solution to a problem Technique for managing complexity Examples \u00b6 An MRT map is an abstraction of the geographically accurate map, but it contains enough information for us to navigate the MRT system. In computer programming this can be: Algorithm Design \u00b6 A plan or a set of step-by-step instructions to solve a problem Each instruction is identified The order in which they should be carried out is planned A starting point for computer programs Represented using pseudocode or flowchart Examples \u00b6 In GCSE-style pseudocode: OUTPUT \"What is your name?\" INPUT name OUTPUT \"Hello\", name OUTPUT \"How old are you?\" INPUT age IF age >= 70 THEN OUTPUT \"You are aged to perfection!\" ELSE OUTPUT \"You are a spring chicken!\" In flowchart:","title":"01 Computational Thinking"},{"location":"SLHL/01/#01-computational-thinking","text":"Summary Decomposition : break the problem down into its components & identify subproblems that need to be solved Pattern Recognition : recognise patterns between subproblems Abstraction/Pattern Generalisation : set up operations that can be used for the subproblems Algorithm Design : solve parallel & sequential subproblems","title":"01 Computational Thinking"},{"location":"SLHL/01/#decomposition","text":"Breaking down complex problem/system -> smaller, more manageable, easier to understand parts Then examine/solve/design individually \u201cDivide and conquer\u201d","title":"Decomposition"},{"location":"SLHL/01/#decomposition-benefits","text":"Simpler to work with, easier to solve Deal with one at a time only Can straightforwardly understand each part before understanding the whole problem Different people can work on different parts at the same time Reduce development time Components can be reused in other programs","title":"Benefits"},{"location":"SLHL/01/#decomposition-examples","text":"Brushing teeth which toothbrush to use how long to brush for how hard to press on our teeth what toothpaste to use Solving crime what crime was committed when the crime was committed where the crime was committed what evidence there is if there were any witnesses if there have recently been any similar crimes Creating app what kind of app do you want to create what your app will look like who is the target audience for your app what your graphics will look like what audio you will include what software you will use to build your app how the user will navigate your app how you will test your app where you will sell your app","title":"Examples"},{"location":"SLHL/01/#pattern-recognition","text":"Finding patterns (similarity/common characteristics) among small, decomposed problems","title":"Pattern Recognition"},{"location":"SLHL/01/#pattern-recognition-benefits","text":"Use the same problem-solving solution for the same pattern Easier & quicker Solve more complex problems more efficiently Solve the problem correctly (because generalisations have been identified)","title":"Benefits"},{"location":"SLHL/01/#pattern-recognition-examples","text":"There might even be patterns within a problem, e.g. for each ingredient, we need its name and a specific measurement.","title":"Examples"},{"location":"SLHL/01/#abstraction","text":"Filtering out/ignoring/taking away unnecessary characteristics/details to concentrate on necessary/essential ones Creating a model (an easier-to-understand version/general idea of a complex system) Tip A single abstraction can represent a whole class of similar things (e.g. for any bus route, we need the bus number, start/end time and bus stops to get on/off). This can be done through successive decomposition and by keeping general patterns and removing specific details .","title":"Abstraction"},{"location":"SLHL/01/#abstraction-benefits","text":"Can be viewed both as a process and as an entity (???) Enables concentration on essential aspects -> ignore distracting details Focus on the right solution to a problem Technique for managing complexity","title":"Benefits"},{"location":"SLHL/01/#abstraction-examples","text":"An MRT map is an abstraction of the geographically accurate map, but it contains enough information for us to navigate the MRT system. In computer programming this can be:","title":"Examples"},{"location":"SLHL/01/#algorithm-design","text":"A plan or a set of step-by-step instructions to solve a problem Each instruction is identified The order in which they should be carried out is planned A starting point for computer programs Represented using pseudocode or flowchart","title":"Algorithm Design"},{"location":"SLHL/01/#algorithm-design-examples","text":"In GCSE-style pseudocode: OUTPUT \"What is your name?\" INPUT name OUTPUT \"Hello\", name OUTPUT \"How old are you?\" INPUT age IF age >= 70 THEN OUTPUT \"You are aged to perfection!\" ELSE OUTPUT \"You are a spring chicken!\" In flowchart:","title":"Examples"},{"location":"SLHL/02a/","text":"02a Problem-Solving & Java (Main) \u00b6 Thinking Procedurally \u00b6 Development phases \u00b6 Identification: identify the problem, understand the problem, formulate the problem Development: explore various alternatives Selection: choose the best alternative Implementation: implement the selected solution Procedure \u00b6 A subroutine that carries out a set of instructions. Sub procedure showProduct(x, y, z) Output \"The product of\", x, y, z, \"is\", x * y * z End sub Call showProduct(5, 10, 15) Benefits \u00b6 Note The main benefit is to prevent repetition . Can be used across multiple problems, not just within Updates ripple through (only need to change one place instead of finding all the occurrences of a code snippet) Well-tested & reliable Speeds up development (no need to write out the same code every time) Abstraction (not concerned with implementation, just purpose) Function \u00b6 A subroutine that carries out a set of instructions and returns a value to the part of the program that called it. Attention Must return a value! Sub function calcProduct(x, y, z) ans = x * y * z return ans End sub prod = Call calcProduct(5, 10, 15) // the return value gets stored in the variable prod Output prod","title":"02a Problem-Solving & Java (Main)"},{"location":"SLHL/02a/#02a-problem-solving-java-main","text":"","title":"02a Problem-Solving &amp; Java (Main)"},{"location":"SLHL/02a/#thinking-procedurally","text":"","title":"Thinking Procedurally"},{"location":"SLHL/02a/#development-phases","text":"Identification: identify the problem, understand the problem, formulate the problem Development: explore various alternatives Selection: choose the best alternative Implementation: implement the selected solution","title":"Development phases"},{"location":"SLHL/02a/#procedure","text":"A subroutine that carries out a set of instructions. Sub procedure showProduct(x, y, z) Output \"The product of\", x, y, z, \"is\", x * y * z End sub Call showProduct(5, 10, 15)","title":"Procedure"},{"location":"SLHL/02a/#benefits","text":"Note The main benefit is to prevent repetition . Can be used across multiple problems, not just within Updates ripple through (only need to change one place instead of finding all the occurrences of a code snippet) Well-tested & reliable Speeds up development (no need to write out the same code every time) Abstraction (not concerned with implementation, just purpose)","title":"Benefits"},{"location":"SLHL/02a/#function","text":"A subroutine that carries out a set of instructions and returns a value to the part of the program that called it. Attention Must return a value! Sub function calcProduct(x, y, z) ans = x * y * z return ans End sub prod = Call calcProduct(5, 10, 15) // the return value gets stored in the variable prod Output prod","title":"Function"}]}